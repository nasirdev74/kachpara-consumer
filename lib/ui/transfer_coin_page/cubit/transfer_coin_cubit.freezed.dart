// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'transfer_coin_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TransferCoinState {
  Status get status => throw _privateConstructorUsedError;
  double get availableBalance => throw _privateConstructorUsedError;
  String get amountTransfer => throw _privateConstructorUsedError;
  String get destinationAddress => throw _privateConstructorUsedError;
  String get tokenId => throw _privateConstructorUsedError;
  String get walletId => throw _privateConstructorUsedError;
  String get idempotencyKey => throw _privateConstructorUsedError;
  String get createdTransactionId => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;
  String? get amountError => throw _privateConstructorUsedError;
  String? get addressError => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TransferCoinStateCopyWith<TransferCoinState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransferCoinStateCopyWith<$Res> {
  factory $TransferCoinStateCopyWith(
          TransferCoinState value, $Res Function(TransferCoinState) then) =
      _$TransferCoinStateCopyWithImpl<$Res, TransferCoinState>;
  @useResult
  $Res call(
      {Status status,
      double availableBalance,
      String amountTransfer,
      String destinationAddress,
      String tokenId,
      String walletId,
      String idempotencyKey,
      String createdTransactionId,
      String? error,
      String? amountError,
      String? addressError});
}

/// @nodoc
class _$TransferCoinStateCopyWithImpl<$Res, $Val extends TransferCoinState>
    implements $TransferCoinStateCopyWith<$Res> {
  _$TransferCoinStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? availableBalance = null,
    Object? amountTransfer = null,
    Object? destinationAddress = null,
    Object? tokenId = null,
    Object? walletId = null,
    Object? idempotencyKey = null,
    Object? createdTransactionId = null,
    Object? error = freezed,
    Object? amountError = freezed,
    Object? addressError = freezed,
  }) {
    return _then(_value.copyWith(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Status,
      availableBalance: null == availableBalance
          ? _value.availableBalance
          : availableBalance // ignore: cast_nullable_to_non_nullable
              as double,
      amountTransfer: null == amountTransfer
          ? _value.amountTransfer
          : amountTransfer // ignore: cast_nullable_to_non_nullable
              as String,
      destinationAddress: null == destinationAddress
          ? _value.destinationAddress
          : destinationAddress // ignore: cast_nullable_to_non_nullable
              as String,
      tokenId: null == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String,
      walletId: null == walletId
          ? _value.walletId
          : walletId // ignore: cast_nullable_to_non_nullable
              as String,
      idempotencyKey: null == idempotencyKey
          ? _value.idempotencyKey
          : idempotencyKey // ignore: cast_nullable_to_non_nullable
              as String,
      createdTransactionId: null == createdTransactionId
          ? _value.createdTransactionId
          : createdTransactionId // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      amountError: freezed == amountError
          ? _value.amountError
          : amountError // ignore: cast_nullable_to_non_nullable
              as String?,
      addressError: freezed == addressError
          ? _value.addressError
          : addressError // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TransferCoinStateImplCopyWith<$Res>
    implements $TransferCoinStateCopyWith<$Res> {
  factory _$$TransferCoinStateImplCopyWith(_$TransferCoinStateImpl value,
          $Res Function(_$TransferCoinStateImpl) then) =
      __$$TransferCoinStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Status status,
      double availableBalance,
      String amountTransfer,
      String destinationAddress,
      String tokenId,
      String walletId,
      String idempotencyKey,
      String createdTransactionId,
      String? error,
      String? amountError,
      String? addressError});
}

/// @nodoc
class __$$TransferCoinStateImplCopyWithImpl<$Res>
    extends _$TransferCoinStateCopyWithImpl<$Res, _$TransferCoinStateImpl>
    implements _$$TransferCoinStateImplCopyWith<$Res> {
  __$$TransferCoinStateImplCopyWithImpl(_$TransferCoinStateImpl _value,
      $Res Function(_$TransferCoinStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? availableBalance = null,
    Object? amountTransfer = null,
    Object? destinationAddress = null,
    Object? tokenId = null,
    Object? walletId = null,
    Object? idempotencyKey = null,
    Object? createdTransactionId = null,
    Object? error = freezed,
    Object? amountError = freezed,
    Object? addressError = freezed,
  }) {
    return _then(_$TransferCoinStateImpl(
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Status,
      availableBalance: null == availableBalance
          ? _value.availableBalance
          : availableBalance // ignore: cast_nullable_to_non_nullable
              as double,
      amountTransfer: null == amountTransfer
          ? _value.amountTransfer
          : amountTransfer // ignore: cast_nullable_to_non_nullable
              as String,
      destinationAddress: null == destinationAddress
          ? _value.destinationAddress
          : destinationAddress // ignore: cast_nullable_to_non_nullable
              as String,
      tokenId: null == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String,
      walletId: null == walletId
          ? _value.walletId
          : walletId // ignore: cast_nullable_to_non_nullable
              as String,
      idempotencyKey: null == idempotencyKey
          ? _value.idempotencyKey
          : idempotencyKey // ignore: cast_nullable_to_non_nullable
              as String,
      createdTransactionId: null == createdTransactionId
          ? _value.createdTransactionId
          : createdTransactionId // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      amountError: freezed == amountError
          ? _value.amountError
          : amountError // ignore: cast_nullable_to_non_nullable
              as String?,
      addressError: freezed == addressError
          ? _value.addressError
          : addressError // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$TransferCoinStateImpl
    with DiagnosticableTreeMixin
    implements _TransferCoinState {
  const _$TransferCoinStateImpl(
      {this.status = Status.init,
      this.availableBalance = 0,
      this.amountTransfer = '',
      this.destinationAddress = '',
      this.tokenId = '',
      this.walletId = '',
      this.idempotencyKey = '',
      this.createdTransactionId = '',
      this.error,
      this.amountError,
      this.addressError});

  @override
  @JsonKey()
  final Status status;
  @override
  @JsonKey()
  final double availableBalance;
  @override
  @JsonKey()
  final String amountTransfer;
  @override
  @JsonKey()
  final String destinationAddress;
  @override
  @JsonKey()
  final String tokenId;
  @override
  @JsonKey()
  final String walletId;
  @override
  @JsonKey()
  final String idempotencyKey;
  @override
  @JsonKey()
  final String createdTransactionId;
  @override
  final String? error;
  @override
  final String? amountError;
  @override
  final String? addressError;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TransferCoinState(status: $status, availableBalance: $availableBalance, amountTransfer: $amountTransfer, destinationAddress: $destinationAddress, tokenId: $tokenId, walletId: $walletId, idempotencyKey: $idempotencyKey, createdTransactionId: $createdTransactionId, error: $error, amountError: $amountError, addressError: $addressError)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TransferCoinState'))
      ..add(DiagnosticsProperty('status', status))
      ..add(DiagnosticsProperty('availableBalance', availableBalance))
      ..add(DiagnosticsProperty('amountTransfer', amountTransfer))
      ..add(DiagnosticsProperty('destinationAddress', destinationAddress))
      ..add(DiagnosticsProperty('tokenId', tokenId))
      ..add(DiagnosticsProperty('walletId', walletId))
      ..add(DiagnosticsProperty('idempotencyKey', idempotencyKey))
      ..add(DiagnosticsProperty('createdTransactionId', createdTransactionId))
      ..add(DiagnosticsProperty('error', error))
      ..add(DiagnosticsProperty('amountError', amountError))
      ..add(DiagnosticsProperty('addressError', addressError));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransferCoinStateImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.availableBalance, availableBalance) ||
                other.availableBalance == availableBalance) &&
            (identical(other.amountTransfer, amountTransfer) ||
                other.amountTransfer == amountTransfer) &&
            (identical(other.destinationAddress, destinationAddress) ||
                other.destinationAddress == destinationAddress) &&
            (identical(other.tokenId, tokenId) || other.tokenId == tokenId) &&
            (identical(other.walletId, walletId) ||
                other.walletId == walletId) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                other.idempotencyKey == idempotencyKey) &&
            (identical(other.createdTransactionId, createdTransactionId) ||
                other.createdTransactionId == createdTransactionId) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.amountError, amountError) ||
                other.amountError == amountError) &&
            (identical(other.addressError, addressError) ||
                other.addressError == addressError));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      availableBalance,
      amountTransfer,
      destinationAddress,
      tokenId,
      walletId,
      idempotencyKey,
      createdTransactionId,
      error,
      amountError,
      addressError);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TransferCoinStateImplCopyWith<_$TransferCoinStateImpl> get copyWith =>
      __$$TransferCoinStateImplCopyWithImpl<_$TransferCoinStateImpl>(
          this, _$identity);
}

abstract class _TransferCoinState implements TransferCoinState {
  const factory _TransferCoinState(
      {final Status status,
      final double availableBalance,
      final String amountTransfer,
      final String destinationAddress,
      final String tokenId,
      final String walletId,
      final String idempotencyKey,
      final String createdTransactionId,
      final String? error,
      final String? amountError,
      final String? addressError}) = _$TransferCoinStateImpl;

  @override
  Status get status;
  @override
  double get availableBalance;
  @override
  String get amountTransfer;
  @override
  String get destinationAddress;
  @override
  String get tokenId;
  @override
  String get walletId;
  @override
  String get idempotencyKey;
  @override
  String get createdTransactionId;
  @override
  String? get error;
  @override
  String? get amountError;
  @override
  String? get addressError;
  @override
  @JsonKey(ignore: true)
  _$$TransferCoinStateImplCopyWith<_$TransferCoinStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
